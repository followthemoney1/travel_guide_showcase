// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'onboarding_screen_cubit.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$OnboardingScreenStateTearOff {
  const _$OnboardingScreenStateTearOff();

  _Initial inital() {
    return const _Initial();
  }

  _LastTab lastTab() {
    return const _LastTab();
  }

  _NextTab nextTab() {
    return const _NextTab();
  }
}

/// @nodoc
const $OnboardingScreenState = _$OnboardingScreenStateTearOff();

/// @nodoc
mixin _$OnboardingScreenState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() lastTab,
    required TResult Function() nextTab,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? lastTab,
    TResult Function()? nextTab,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) inital,
    required TResult Function(_LastTab value) lastTab,
    required TResult Function(_NextTab value) nextTab,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? inital,
    TResult Function(_LastTab value)? lastTab,
    TResult Function(_NextTab value)? nextTab,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OnboardingScreenStateCopyWith<$Res> {
  factory $OnboardingScreenStateCopyWith(OnboardingScreenState value,
          $Res Function(OnboardingScreenState) then) =
      _$OnboardingScreenStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$OnboardingScreenStateCopyWithImpl<$Res>
    implements $OnboardingScreenStateCopyWith<$Res> {
  _$OnboardingScreenStateCopyWithImpl(this._value, this._then);

  final OnboardingScreenState _value;
  // ignore: unused_field
  final $Res Function(OnboardingScreenState) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res>
    extends _$OnboardingScreenStateCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc

class _$_Initial with DiagnosticableTreeMixin implements _Initial {
  const _$_Initial();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'OnboardingScreenState.inital()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'OnboardingScreenState.inital'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() lastTab,
    required TResult Function() nextTab,
  }) {
    return inital();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? lastTab,
    TResult Function()? nextTab,
    required TResult orElse(),
  }) {
    if (inital != null) {
      return inital();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) inital,
    required TResult Function(_LastTab value) lastTab,
    required TResult Function(_NextTab value) nextTab,
  }) {
    return inital(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? inital,
    TResult Function(_LastTab value)? lastTab,
    TResult Function(_NextTab value)? nextTab,
    required TResult orElse(),
  }) {
    if (inital != null) {
      return inital(this);
    }
    return orElse();
  }
}

abstract class _Initial implements OnboardingScreenState {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$LastTabCopyWith<$Res> {
  factory _$LastTabCopyWith(_LastTab value, $Res Function(_LastTab) then) =
      __$LastTabCopyWithImpl<$Res>;
}

/// @nodoc
class __$LastTabCopyWithImpl<$Res>
    extends _$OnboardingScreenStateCopyWithImpl<$Res>
    implements _$LastTabCopyWith<$Res> {
  __$LastTabCopyWithImpl(_LastTab _value, $Res Function(_LastTab) _then)
      : super(_value, (v) => _then(v as _LastTab));

  @override
  _LastTab get _value => super._value as _LastTab;
}

/// @nodoc

class _$_LastTab with DiagnosticableTreeMixin implements _LastTab {
  const _$_LastTab();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'OnboardingScreenState.lastTab()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'OnboardingScreenState.lastTab'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LastTab);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() lastTab,
    required TResult Function() nextTab,
  }) {
    return lastTab();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? lastTab,
    TResult Function()? nextTab,
    required TResult orElse(),
  }) {
    if (lastTab != null) {
      return lastTab();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) inital,
    required TResult Function(_LastTab value) lastTab,
    required TResult Function(_NextTab value) nextTab,
  }) {
    return lastTab(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? inital,
    TResult Function(_LastTab value)? lastTab,
    TResult Function(_NextTab value)? nextTab,
    required TResult orElse(),
  }) {
    if (lastTab != null) {
      return lastTab(this);
    }
    return orElse();
  }
}

abstract class _LastTab implements OnboardingScreenState {
  const factory _LastTab() = _$_LastTab;
}

/// @nodoc
abstract class _$NextTabCopyWith<$Res> {
  factory _$NextTabCopyWith(_NextTab value, $Res Function(_NextTab) then) =
      __$NextTabCopyWithImpl<$Res>;
}

/// @nodoc
class __$NextTabCopyWithImpl<$Res>
    extends _$OnboardingScreenStateCopyWithImpl<$Res>
    implements _$NextTabCopyWith<$Res> {
  __$NextTabCopyWithImpl(_NextTab _value, $Res Function(_NextTab) _then)
      : super(_value, (v) => _then(v as _NextTab));

  @override
  _NextTab get _value => super._value as _NextTab;
}

/// @nodoc

class _$_NextTab with DiagnosticableTreeMixin implements _NextTab {
  const _$_NextTab();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'OnboardingScreenState.nextTab()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'OnboardingScreenState.nextTab'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _NextTab);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() inital,
    required TResult Function() lastTab,
    required TResult Function() nextTab,
  }) {
    return nextTab();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? inital,
    TResult Function()? lastTab,
    TResult Function()? nextTab,
    required TResult orElse(),
  }) {
    if (nextTab != null) {
      return nextTab();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) inital,
    required TResult Function(_LastTab value) lastTab,
    required TResult Function(_NextTab value) nextTab,
  }) {
    return nextTab(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? inital,
    TResult Function(_LastTab value)? lastTab,
    TResult Function(_NextTab value)? nextTab,
    required TResult orElse(),
  }) {
    if (nextTab != null) {
      return nextTab(this);
    }
    return orElse();
  }
}

abstract class _NextTab implements OnboardingScreenState {
  const factory _NextTab() = _$_NextTab;
}
